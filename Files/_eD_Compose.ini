;
;;  Compose table definitions
;;  for Portable Keyboard Layout by Farkas Máté [https://github.com/Portable-Keyboard-Layout]
;;  edition DreymaR (Øystein B Gadmar, 2015-)   [https://github.com/DreymaR/BigBagKbdTrixPKL]
;
;;  This file is Work-In-Progress for an EPKL Compose method based on the X11 tables
;;  The Compose table has to be parsed and any non-<Multi_key> entries should be discarded.
;
;;  - EPKL Compose is post-hoc: You press the Compose key after typing the sequence instead of before as in Linux.
;;  - Additive Completion adds to whatever was written. These tables are marked with a + in the tables list.
;;  - For a normal post-hoc Compose of length #, {Backspace #} is sent first to delete the composing sequence.
;;  - Entry keys may be defined using hex Unicode point sequences, or with simple character strings.
;;      - Simple character string keys cannot contain advanced glyphs that aren't allowed in .ini file keys.
;;      - Simple key entries cannot distinguish case, but the Title Case key is automatically generated as well.
;;      - For full control over case and glyph, use the 0x####_0x####... format with Unicode hex values.
;;  - X11-type composes may be converted to the format seen in the tables quite easily.
;;  - NOTE: You can set the desired compose lengths to look for in an ordered list below, in the 'lengths' setting.
;;      - If lengths are set to 3,2 for instance, 3-key composes will take precedence over 2-key composes.
;;      - If there are composes of the same length in several tables, the first one listed will take precedence.
;
;;  eD WIP:
;;  EPKL should be able to import an X11 Compose table such as /usr/share/X11/locale/en_US.UTF-8/Compose with ~3000 entries.
;

[pkl]
;tables  = +dynCmk, x11, strings 		; Which compose tables to use. A "+" prefix means additive composing. Late entries may overwrite early ones.
lengths = 3,2,1 	;4, 				; How many previous characters to use as Compose key sequences, prioritized.

[compose-tables]
;; Named Compose/Completion keys have their own prioritized set of compose tables defined here. Length still wins.
Def     = +dynCmk, strings, x11 		; The default ©Def Compose key. By default mapped to the ISO key; see EPKL_Layouts_Default.ini
dCo     = +dynCmk, strings 				; Colemak Completion key, with some additional string composes.
x11     = x11 							; X11 Compose key


[compose_dynCmk]
;;  The dynamic 1-key completions for Colemak, by Semi at the Colemak Discord:
;;  
;;  Dynamic Usage: 0.99%
;;      e, 0.183%    sc 0.138%    ue 0.129%    y. 0.087%
;;      nk 0.079%    pt 0.078%    kn 0.055%    wr 0.032%
;;      dg 0.026%    lk 0.026%    cs 0.024%    hn 0.023%
;
;;      az 0.019%    za 0.018%    rw 0.015%    gt 0.012%
;;      bt 0.010%    tp 0.008%    fs 0.007%    mn 0.006%
;;      i. 0.005%    /o 0.003%    .i 0.003%    o; 0.002%
;;      vd 0.001%    qa 0.001%    jm 0.000%    xw 0.000%
;;      ;o 0.000%    ,e 0.000%
;;  True SFBs (not covered by dynamic usage): 0.37%
;;      nl 0.068%    yi 0.037%    lm 0.025%    dv 0.022%
;;      eu 0.020%    nm 0.020%    hl 0.017%    sf 0.016%
;;
;;  - Semi suggests a usefulness cutoff around I(-PD). 
;;  - I suggest B(-T) instead, to leave room for the 'the' and 'and' trigrams. ￣(=⌒ᆺ⌒=)￣
;;  - The "true SFBs" covered above are all within the top 12 dynamic keys.
;;  - I don't think most people would actually bother with learning completions below 0.05% or so (the top 7–8)?
;
e       = ,   	; e,        .18% 		; Note that there are many X11 composes ending w/ "e" too. You can't have both!
s       = c   	; sc/Sc     .14%
u       = e   	; ue/Ue     .13%
y       = .   	; etc...
n       = l   	; nl – chosen over nk, as the nk (0.08%) SFB is easily alt-fingerable but nl (0.07%) is not
p       = t   	; 
k       = n   	; 
w       = r   	; 
d       = g   	; dlch...
l       = k   	; 
c       = s   	; 
;h       = n   	; 
;a       = z   	; azrg... btfm i/.o vqjx ;,
z       = a   	; 
;r       = w   	; 
g       = t   	; 

;;  Some keys get trigram completions instead, as their problem bigrams are rare and the trigrams useful.
;;  Top English trigrams (lists vary): 
;;      the and tha ent   ing ion tio for   nde has nce edt   tis oft sth men   					https://en.wikipedia.org/wiki/Trigram
;;      the and ing her   tha ent ere ion   eth nth hat int   for all sth ter   est tio his oft 	https://www.dcode.fr/trigrams
;;      the and ing her   hat his tha ere   for ent ion ter   was you ith ver   all wit thi tio 	https://www3.nd.edu/~busiforc/handouts/cryptography/Letter%20Frequencies.html
;;      the and ing ion   tio ent ati for   her ter hat tha   ere ate his con   res vel all ons 	https://norvig.com/mayzner.html
;;  Top English trigrams by letter (t a i h e f n o s m w y; none with g x):
;;      the/tha/thi/tio/ter and/ati/ate ing/ion/int/ith her/his/hat ent/ere/eth for nde/nce oft/ons sth men was/wit con vel you
h       = er  	; her/Her
a       = nd  	; and/And
r       = es  	; res/Res (rare; tossup with the rw bigram?)
t       = he  	; the/The
f       = or  	; for/For
m       = en  	; men/Men
i       = on  	; ion/Ion – chosen over ing/Ing as it's a mixed roll
o       = ft  	; oft/Oft
q       = ue  	; que/Que
x       = ce   	; ???


[compose_strings]
na      = <YourNameHere>
em      = <YourE-MailHere>
hw      = ¶001 							; Prefix-Entry syntax is allowed!
da      = @0b4 							; This is the dead_acute DK, as defined in _eD_DeadKeys.ini
dk      = @ex1 							; Kaomoji revisited...  ￣(=⌒ᆺ⌒=)￣
0x002e  = ! 	; period = exclam (could actually have used a period as key in this case)


[compose_x11]
;;  NOTE: Keys are made from Unicode values found in keysymdef, yielding .ini compliant keys.
;;  A few(!) sample entries from XLib /usr/share/X11/locale/en_US.UTF-8/Compose are:
;;  <Multi_key> <grave> <e>          	: "è"   egrave # LATIN SMALL LETTER E WITH GRAVE
;;  <Multi_key> <e> <grave>          	: "è"   egrave # LATIN SMALL LETTER E WITH GRAVE
;;  <Multi_key> <apostrophe> <e>     	: "é"   eacute # LATIN SMALL LETTER E WITH ACUTE
;;  <Multi_key> <e> <apostrophe>     	: "é"   eacute # LATIN SMALL LETTER E WITH ACUTE
;;  <Multi_key> <grave> <o>          	: "ò"   ograve # LATIN SMALL LETTER O WITH GRAVE
;;  <Multi_key> <o> <grave>          	: "ò"   ograve # LATIN SMALL LETTER O WITH GRAVE
;;  <Multi_key> <apostrophe> <o>     	: "ó"   oacute # LATIN SMALL LETTER O WITH ACUTE
;;  <Multi_key> <o> <apostrophe>     	: "ó"   oacute # LATIN SMALL LETTER O WITH ACUTE
;;  <Multi_key> <o> <e>              	: "œ"   oe # LATIN SMALL LIGATURE OE
;;  <Multi_key> <O> <E>              	: "Œ"   OE # LATIN CAPITAL LIGATURE OE
;
;;  A few sample entries from XLib keysymdef.h are:
;;  #define XK_e                             0x0065  /* U+0065 LATIN SMALL LETTER E */
;;  #define XK_grave                         0x0060  /* U+0060 GRAVE ACCENT */
;;  #define XK_apostrophe                    0x0027  /* U+0027 APOSTROPHE */
;;  #define XK_o                             0x006f  /* U+006F LATIN SMALL LETTER O */
;;  #define XK_E                             0x0045  /* U+0045 LATIN CAPITAL LETTER E */
;;  #define XK_O                             0x004f  /* U+004F LATIN CAPITAL LETTER O */

0x0060_0x0065               = è 	; grave  + e      = egrave # LATIN SMALL LETTER E WITH GRAVE
0x0065_0x0060               = è 	; e      + grave  = egrave # LATIN SMALL LETTER E WITH GRAVE
0x0027_0x0065               = é 	; apostr + e      = eacute # LATIN SMALL LETTER E WITH ACUTE
0x0065_0x0027               = é 	; e      + apostr = eacute # LATIN SMALL LETTER E WITH ACUTE
0x0060_0x006f               = ò 	; grave  + o      = ograve # LATIN SMALL LETTER O WITH GRAVE
0x006f_0x0060               = ò 	; o      + grave  = ograve # LATIN SMALL LETTER O WITH GRAVE
0x0027_0x006f               = ó 	; apostr + o      = oacute # LATIN SMALL LETTER O WITH ACUTE
0x006f_0x0027               = ó 	; o      + apostr = oacute # LATIN SMALL LETTER O WITH ACUTE
0x006f_0x0065               = œ 	; o      + e      = oe     # LATIN SMALL LIGATURE OE
0x004f_0x0045               = Œ 	; O      + E      = OE     # LATIN CAPITAL LIGATURE OE
